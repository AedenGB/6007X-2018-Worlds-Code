#pragma config(Sensor, in1,    mogoPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  driveEncoderR,  sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  driveEncoderL,  sensorQuadEncoder)
#pragma config(Motor,  port1,           driveRB,       tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           driveRM,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           driveRF,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveLF,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           driveLM,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          driveLB,       tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"


//various header files
#include "utilities.c"         //generally useful fuctions
#include "PID.c"               //pid struct and fucntions
#include "mogoDriveControl.c"  //6 pid loop control task that runs mobile goal transmission

string autons[] = {"hi", "hello", "my boy"};//list of 14 character strings naming autons
#include "autonSelect.c"//autonomous selection task

void pre_auton()
{
	bStopTasksBetweenModes = true;
	stopTask(autonSelect);
	startTask(autonSelect);
	//
	resetGyro();
}

void pre_auton(){
}


task autonomous(){
	switch(autonType){
		case 0:
		displayAuton(autonType);

		break;
		case 1:
		displayAuton(autonType);

		break;
		case 2:
		displayAuton(autonType);

		break;
		default:
		break;
	}
}

task usercontrol(){
	//startTask(mogoDriveControl);
	int motorValue = 0;
	struct PIDLoop mogoPID;
	initializePIDLoop(mogoPID, 0.1, 0, 0, 10, mogoPot);
	while(true){
		motorValue = limit(calculatePIDValue(mogoPID));
		writeDebugStream("motorPower:");
		printToDebug(motorValue);
		motor[driveLM] = motor[driveRM] = -motorValue;
		delay(10);
		motor[driveLF] = vexRT(Ch2);
	}
	/////////////////////////////////////////////////////
	//																								 //
	//																								 //
	//							reverse driveEncoderR							 //
	//																								 //
	//																								 //
	/////////////////////////////////////////////////////
}
